(library
  (common)
  (export char-utf8-len
	  fmap
	  err
	  make-hint
	  make-hint-with-span
	  is-error?
	  is-valid?
	  dbg
	  and-then)
  (import (rnrs base)
	  (rnrs io simple)
	  (rnrs))

  ; Returns the length in bytes the character takes in utf8.
  (define (char-utf8-len c)
    (let ([n (char->integer c)])
      (cond
	[(<= n #x7F) 1]
	[(<= n #x7FF) 2]
	[(<= n #xFFFF) 3]
	[else 4])))

  ;; Returns a triple representing an error from a function. The last element
  ;; may be a pair '(hint . <hint>).
  (define err
    (lambda (e . extra)
      (cons 'error
	     (if (null? extra)
	       e
	       (cons e extra)))))

  (define make-hint
    (lambda (msg)
      (make-hint-with-span #f msg)))

  (define make-hint-with-span
    (lambda (span msg)
      (cons span
	    msg)))

  ;; Returns `#t` if `x` is an error generated from `err`.
  (define is-error?
    (lambda (x)
      (and (pair? x)
	   (eq? 'error (car x)))))

  ;; Applies `f` to `m` if it is not an error value (i.e. `#f`, or an error
  ;; generated by `err`.)
  (define fmap
    (lambda (f m)
      (cond
	[(and (pair? m)
	      (eq? 'error (car m)))
	 m]
	[m (f m)]
	[else m])))

  ;; Evaluates `e`, prints it and returns it.
  (define-syntax dbg
    (syntax-rules ()
      [(dbg e)
       (let ([t e])
	 (display (syntax->datum #'e))
	 (display ": ")
	 (display t)
	 (newline)
	 (newline)
	 t)]))

  ;; Returns `#f` if `x` is `#f` or an error, a truthy value otherwise.
  (define is-valid?
    (lambda (x)
      (and x
	   (not (and (pair? x)
		     (eq? 'error (car x)))))))

  (define-syntax and-then
    (syntax-rules (->)
      [(_ cond
	  (-> x body bodys ...))
       (let ([t cond])
	 (if (is-valid? t)
	   ((lambda x body bodys ...)
	    t)
	   t))]
      [(_ cond
	  fn)
       (let ([t cond])
	 (if (is-valid? t)
	   (fn t)
	   t))]
      [(_ cond
	  fn
	  rest ...)
       (and-then
	 (and-then cond fn)
	 rest ...)]
      [(_ cond
	  (x body bodys ...)
	  rest ...)
       (and-then
	 (and-then cond (x body bodys ...))
	 rest ...)])))
